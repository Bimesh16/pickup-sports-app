package com.bmessi.pickupsportsapp.service.cricket;

import com.bmessi.pickupsportsapp.entity.User;
import com.bmessi.pickupsportsapp.entity.cricket.*;
import com.bmessi.pickupsportsapp.entity.game.Game;
import com.bmessi.pickupsportsapp.entity.game.Team;
import com.bmessi.pickupsportsapp.repository.cricket.*;
import com.bmessi.pickupsportsapp.service.notification.NotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.server.ResponseStatusException;
import org.springframework.http.HttpStatus;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Service for cricket match scoring and statistics management.
 * 
 * <p>This service handles all cricket-specific functionality including live scoring,
 * ball-by-ball tracking, player statistics, and match management.</p>
 * 
 * <p><strong>Core Features:</strong></p>
 * <ul>
 *   <li><strong>Live Scoring:</strong> Real-time ball-by-ball match updates</li>
 *   <li><strong>Statistics Tracking:</strong> Comprehensive player and team stats</li>
 *   <li><strong>Match Management:</strong> Toss, innings transitions, match completion</li>
 *   <li><strong>Real-time Updates:</strong> WebSocket updates for live followers</li>
 * </ul>
 * 
 * @author Pickup Sports App Team
 * @version 2.0.0
 * @since 2.0.0
 */
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class CricketScoringService {

    private final CricketMatchRepository cricketMatchRepository;
    private final CricketInningsRepository cricketInningsRepository;
    private final CricketPlayerPerformanceRepository playerPerformanceRepository;
    private final CricketBallRepository cricketBallRepository;
    private final SimpMessagingTemplate messagingTemplate;
    private final NotificationService notificationService;

    /**
     * Initialize cricket match from game.
     */
    public CricketMatch initializeCricketMatch(Game game, CricketMatch.CricketFormat format) {
        log.info("Initializing cricket match for game {} with format {}", game.getId(), format);

        if (!game.getSport().equalsIgnoreCase("Cricket")) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Game must be cricket sport");
        }

        CricketMatch cricketMatch = CricketMatch.builder()
            .game(game)
            .matchFormat(format)
            .matchStatus(CricketMatch.MatchStatus.NOT_STARTED)
            .maxOversPerInnings(format.getMaxOvers())
            .inningsPerTeam(format.getInningsPerTeam())
            .currentInnings(0)
            .dlsApplicable(false)
            .build();

        CricketMatch saved = cricketMatchRepository.save(cricketMatch);

        // Initialize innings for the match
        initializeInnings(saved);

        log.info("Cricket match initialized with ID: {}", saved.getId());
        return saved;
    }

    /**
     * Conduct toss and start match.
     */
    public TossResult conductToss(Long matchId, Team tossWinningTeam, CricketMatch.TossDecision decision) {
        CricketMatch match = getCricketMatch(matchId);

        if (match.getMatchStatus() != CricketMatch.MatchStatus.NOT_STARTED) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Toss already conducted");
        }

        match.setTossWinningTeam(tossWinningTeam);
        match.setTossDecision(decision);
        match.setMatchStatus(CricketMatch.MatchStatus.TOSS);

        // Set batting and bowling teams based on toss decision
        if (decision == CricketMatch.TossDecision.BAT_FIRST) {
            match.setBattingTeam(tossWinningTeam);
            match.setBowlingTeam(getOtherTeam(match, tossWinningTeam));
        } else {
            match.setBowlingTeam(tossWinningTeam);
            match.setBattingTeam(getOtherTeam(match, tossWinningTeam));
        }

        CricketMatch saved = cricketMatchRepository.save(match);

        // Send real-time toss update
        TossResult result = TossResult.builder()
            .matchId(matchId)
            .tossWinningTeam(tossWinningTeam.getTeamName())
            .decision(decision.getDescription())
            .battingFirst(saved.getBattingTeam().getTeamName())
            .bowlingFirst(saved.getBowlingTeam().getTeamName())
            .build();

        sendRealTimeUpdate(matchId, "toss_completed", result);
        return result;
    }

    /**
     * Start the cricket match.
     */
    public void startMatch(Long matchId) {
        CricketMatch match = getCricketMatch(matchId);

        if (match.getMatchStatus() != CricketMatch.MatchStatus.TOSS) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Match must complete toss before starting");
        }

        match.startMatch();
        match.setCurrentInnings(1);

        // Start first innings
        CricketInnings firstInnings = match.getInnings().get(0);
        firstInnings.startInnings();

        cricketMatchRepository.save(match);
        cricketInningsRepository.save(firstInnings);

        // Send match start notification
        sendRealTimeUpdate(matchId, "match_started", 
            MatchUpdateData.builder()
                .matchId(matchId)
                .status(match.getMatchStatus())
                .currentInnings(match.getCurrentInnings())
                .battingTeam(match.getBattingTeam().getTeamName())
                .bowlingTeam(match.getBowlingTeam().getTeamName())
                .build());

        log.info("Cricket match {} started", matchId);
    }

    /**
     * Record a ball delivery with all details.
     */
    public BallResult recordBall(Long matchId, BallDeliveryRequest request) {
        CricketMatch match = getCricketMatch(matchId);
        CricketInnings currentInnings = match.getCurrentInnings();

        if (currentInnings == null || currentInnings.getInningsStatus() != CricketInnings.InningsStatus.IN_PROGRESS) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "No active innings to record ball");
        }

        // Create ball record
        CricketBall ball = CricketBall.builder()
            .innings(currentInnings)
            .overNumber(currentInnings.getOversCompleted() + 1)
            .ballNumber(currentInnings.getBallsInCurrentOver() + 1)
            .bowler(request.bowler())
            .batsmanOnStrike(request.batsmanOnStrike())
            .batsmanNonStrike(request.batsmanNonStrike())
            .runsOffBall(request.runs())
            .ballOutcome(request.outcome())
            .isWicket(request.isWicket())
            .wicketType(request.wicketType())
            .fielder(request.fielder())
            .isExtra(request.isExtra())
            .extraType(request.extraType())
            .shotType(request.shotType())
            .commentary(request.commentary())
            .build();

        CricketBall savedBall = cricketBallRepository.save(ball);

        // Update innings totals
        updateInningsTotals(currentInnings, savedBall);

        // Update player performances
        updatePlayerPerformances(currentInnings, savedBall);

        // Check for milestones
        checkMilestones(savedBall);

        // Check if over is complete
        if (ball.endsOver()) {
            currentInnings.completeOver();
            checkInningsCompletion(currentInnings, match);
        } else {
            currentInnings.setBallsInCurrentOver(currentInnings.getBallsInCurrentOver() + 1);
        }

        cricketInningsRepository.save(currentInnings);

        // Create result
        BallResult result = BallResult.builder()
            .ballId(savedBall.getId())
            .runs(savedBall.getRunsOffBall())
            .outcome(savedBall.getBallOutcome())
            .isWicket(savedBall.getIsWicket())
            .currentScore(currentInnings.getCurrentScore())
            .oversDisplay(currentInnings.getOversDisplay())
            .runRate(currentInnings.getCurrentRunRate())
            .requiredRunRate(currentInnings.getRequiredRunRate())
            .build();

        // Send real-time update
        sendRealTimeUpdate(matchId, "ball_completed", result);

        log.debug("Ball recorded for match {}: {} runs, outcome: {}", matchId, request.runs(), request.outcome());
        return result;
    }

    /**
     * Complete current innings and start next if applicable.
     */
    public InningsTransitionResult completeCurrentInnings(Long matchId, CricketInnings.InningsConclusion conclusion) {
        CricketMatch match = getCricketMatch(matchId);
        CricketInnings currentInnings = match.getCurrentInnings();

        if (currentInnings == null) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "No active innings to complete");
        }

        // End current innings
        currentInnings.endInnings(conclusion);
        cricketInningsRepository.save(currentInnings);

        // Check if match should continue or end
        boolean matchComplete = shouldEndMatch(match);
        
        if (matchComplete) {
            return completeMatch(match);
        } else {
            return startNextInnings(match);
        }
    }

    /**
     * Get current match scorecard.
     */
    @Transactional(readOnly = true)
    public CricketScorecard getCurrentScorecard(Long matchId) {
        CricketMatch match = getCricketMatch(matchId);
        
        List<CricketInnings> allInnings = cricketInningsRepository.findByMatchIdOrderByInningsNumber(matchId);
        List<CricketPlayerPerformance> allPerformances = playerPerformanceRepository.findByMatchId(matchId);

        return CricketScorecard.builder()
            .matchId(matchId)
            .matchFormat(match.getMatchFormat())
            .matchStatus(match.getMatchStatus())
            .currentInnings(match.getCurrentInnings())
            .innings(allInnings)
            .playerPerformances(allPerformances)
            .tossInfo(TossInfo.builder()
                .tossWinningTeam(match.getTossWinningTeam() != null ? match.getTossWinningTeam().getTeamName() : null)
                .decision(match.getTossDecision() != null ? match.getTossDecision().getDescription() : null)
                .build())
            .matchResult(match.getMatchResult())
            .winningTeam(match.getWinningTeam() != null ? match.getWinningTeam().getTeamName() : null)
            .manOfTheMatch(match.getManOfTheMatch() != null ? match.getManOfTheMatch().getUsername() : null)
            .build();
    }

    // ===== PRIVATE HELPER METHODS =====

    private CricketMatch getCricketMatch(Long matchId) {
        return cricketMatchRepository.findById(matchId)
            .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Cricket match not found"));
    }

    private void initializeInnings(CricketMatch match) {
        List<Team> teams = getTeamsForGame(match.getGame());
        
        if (teams.size() != 2) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Cricket requires exactly 2 teams");
        }

        Team teamA = teams.get(0);
        Team teamB = teams.get(1);

        // Create innings based on format
        for (int i = 1; i <= match.getInningsPerTeam() * 2; i++) {
            Team battingTeam = (i % 2 == 1) ? teamA : teamB;
            Team bowlingTeam = (i % 2 == 1) ? teamB : teamA;

            CricketInnings innings = CricketInnings.builder()
                .cricketMatch(match)
                .inningsNumber(i)
                .battingTeam(battingTeam)
                .bowlingTeam(bowlingTeam)
                .inningsStatus(CricketInnings.InningsStatus.NOT_STARTED)
                .build();

            cricketInningsRepository.save(innings);
        }
    }

    private Team getOtherTeam(CricketMatch match, Team knownTeam) {
        List<Team> teams = getTeamsForGame(match.getGame());
        return teams.stream()
            .filter(team -> !team.getId().equals(knownTeam.getId()))
            .findFirst()
            .orElseThrow(() -> new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Could not find other team"));
    }

    private List<Team> getTeamsForGame(Game game) {
        // This would be implemented in TeamRepository
        return teamRepository.findByGameId(game.getId());
    }

    private void updateInningsTotals(CricketInnings innings, CricketBall ball) {
        // Add runs to innings total
        innings.addRuns(ball.getRunsOffBall(), ball.getIsExtra());

        // Handle extras
        if (ball.getIsExtra()) {
            switch (ball.getExtraType()) {
                case WIDE -> innings.setWides(innings.getWides() + 1);
                case NO_BALL -> innings.setNoBalls(innings.getNoBalls() + 1);
                case BYE -> innings.setByes(innings.getByes() + ball.getRunsOffBall());
                case LEG_BYE -> innings.setLegByes(innings.getLegByes() + ball.getRunsOffBall());
                case PENALTY -> innings.setPenaltyRuns(innings.getPenaltyRuns() + ball.getRunsOffBall());
            }
        }

        // Handle wicket
        if (ball.getIsWicket()) {
            innings.addWicket();
        }
    }

    private void updatePlayerPerformances(CricketInnings innings, CricketBall ball) {
        // Update batsman performance
        updateBatsmanPerformance(innings, ball.getBatsmanOnStrike(), ball);

        // Update bowler performance
        updateBowlerPerformance(innings, ball.getBowler(), ball);

        // Update fielder performance if applicable
        if (ball.getFielder() != null) {
            updateFielderPerformance(innings, ball.getFielder(), ball);
        }
    }

    private void updateBatsmanPerformance(CricketInnings innings, User batsman, CricketBall ball) {
        CricketPlayerPerformance performance = getOrCreatePlayerPerformance(innings, batsman);

        // Update batting stats
        if (!ball.getIsExtra()) {
            performance.setBallsFaced(performance.getBallsFaced() + 1);
        }

        performance.setRunsScored(performance.getRunsScored() + ball.getRunsOffBall());

        // Count boundaries
        if (ball.getRunsOffBall() == 4) {
            performance.setFoursHit(performance.getFoursHit() + 1);
        } else if (ball.getRunsOffBall() == 6) {
            performance.setSixesHit(performance.getSixesHit() + 1);
        }

        // Handle dismissal
        if (ball.getIsWicket()) {
            performance.setIsNotOut(false);
            performance.setDismissalType(ball.getWicketType());
            performance.setDismissedByBowler(ball.getBowler());
            performance.setDismissedByFielder(ball.getFielder());
        }

        // Recalculate derived stats
        performance.calculateStrikeRate();
        performance.calculateImpactScore();

        playerPerformanceRepository.save(performance);
    }

    private void updateBowlerPerformance(CricketInnings innings, User bowler, CricketBall ball) {
        CricketPlayerPerformance performance = getOrCreatePlayerPerformance(innings, bowler);

        // Update bowling stats
        performance.setRunsConceded(performance.getRunsConceded() + ball.getRunsOffBall());

        if (ball.getIsWicket()) {
            performance.setWicketsTaken(performance.getWicketsTaken() + 1);
        }

        // Count extras
        if (ball.getIsExtra()) {
            switch (ball.getExtraType()) {
                case WIDE -> performance.setWidesBowled(performance.getWidesBowled() + 1);
                case NO_BALL -> performance.setNoBallsBowled(performance.getNoBallsBowled() + 1);
            }
        }

        // Update overs bowled (this is simplified - real implementation needs over tracking)
        if (ball.endsOver()) {
            performance.setOversBowled(performance.getOversBowled() + 1.0);
        }

        // Check for maiden over
        if (ball.endsOver() && isMailden(innings, bowler, ball.getOverNumber())) {
            performance.setMaidenOvers(performance.getMaidenOvers() + 1);
        }

        // Recalculate derived stats
        performance.calculateEconomyRate();
        performance.calculateImpactScore();

        playerPerformanceRepository.save(performance);
    }

    private void updateFielderPerformance(CricketInnings innings, User fielder, CricketBall ball) {
        CricketPlayerPerformance performance = getOrCreatePlayerPerformance(innings, fielder);

        if (ball.getIsWicket()) {
            switch (ball.getWicketType()) {
                case CAUGHT -> performance.setCatchesTaken(performance.getCatchesTaken() + 1);
                case RUN_OUT -> performance.setRunOuts(performance.getRunOuts() + 1);
                case STUMPED -> performance.setStumpings(performance.getStumpings() + 1);
            }
        }

        performance.calculateImpactScore();
        playerPerformanceRepository.save(performance);
    }

    private CricketPlayerPerformance getOrCreatePlayerPerformance(CricketInnings innings, User player) {
        return playerPerformanceRepository.findByInningsAndPlayer(innings, player)
            .orElseGet(() -> {
                CricketPlayerPerformance performance = CricketPlayerPerformance.builder()
                    .innings(innings)
                    .player(player)
                    .playerRole(determinePlayerRole(player))
                    .build();
                return playerPerformanceRepository.save(performance);
            });
    }

    private CricketPlayerPerformance.PlayerRole determinePlayerRole(User player) {
        // Logic to determine role based on user profile, game context, etc.
        // For now, default to BATSMAN
        return CricketPlayerPerformance.PlayerRole.BATSMAN;
    }

    private void checkMilestones(CricketBall ball) {
        // Check for batting milestones
        CricketPlayerPerformance batsmanPerf = getOrCreatePlayerPerformance(ball.getInnings(), ball.getBatsmanOnStrike());
        
        if (batsmanPerf.getRunsScored() == 50) {
            sendMilestoneNotification(ball.getInnings().getCricketMatch().getId(), 
                ball.getBatsmanOnStrike().getUsername() + " reaches half-century!");
        } else if (batsmanPerf.getRunsScored() == 100) {
            sendMilestoneNotification(ball.getInnings().getCricketMatch().getId(),
                ball.getBatsmanOnStrike().getUsername() + " scores a century!");
        }

        // Check for bowling milestones
        CricketPlayerPerformance bowlerPerf = getOrCreatePlayerPerformance(ball.getInnings(), ball.getBowler());
        
        if (ball.getIsWicket() && bowlerPerf.getWicketsTaken() == 5) {
            sendMilestoneNotification(ball.getInnings().getCricketMatch().getId(),
                ball.getBowler().getUsername() + " takes 5-wicket haul!");
        }
    }

    private boolean isMailden(CricketInnings innings, User bowler, int overNumber) {
        List<CricketBall> overBalls = cricketBallRepository.findByInningsAndOverNumberAndBowler(innings, overNumber, bowler);
        return overBalls.stream().mapToInt(CricketBall::getRunsOffBall).sum() == 0;
    }

    private boolean shouldEndMatch(CricketMatch match) {
        int completedInnings = (int) match.getInnings().stream()
            .filter(innings -> innings.getInningsStatus() == CricketInnings.InningsStatus.COMPLETED)
            .count();

        // For T20/ODI: match ends after 2 innings
        if (match.getMatchFormat() == CricketMatch.CricketFormat.T20 || 
            match.getMatchFormat() == CricketMatch.CricketFormat.ODI) {
            return completedInnings >= 2;
        }

        // For Test: more complex logic based on declarations, follow-on, etc.
        return false; // Simplified for now
    }

    private InningsTransitionResult startNextInnings(CricketMatch match) {
        int nextInningsNumber = match.getCurrentInnings() + 1;
        
        Optional<CricketInnings> nextInnings = match.getInnings().stream()
            .filter(innings -> innings.getInningsNumber() == nextInningsNumber)
            .findFirst();

        if (nextInnings.isEmpty()) {
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Next innings not found");
        }

        CricketInnings innings = nextInnings.get();
        innings.startInnings();

        // Switch batting and bowling teams
        match.setBattingTeam(innings.getBattingTeam());
        match.setBowlingTeam(innings.getBowlingTeam());
        match.setCurrentInnings(nextInningsNumber);

        // Set target for second innings
        if (nextInningsNumber == 2) {
            CricketInnings firstInnings = match.getInnings().get(0);
            innings.setTargetScore(firstInnings.getTotalRuns() + 1);
        }

        cricketMatchRepository.save(match);
        cricketInningsRepository.save(innings);

        InningsTransitionResult result = InningsTransitionResult.builder()
            .matchId(match.getId())
            .completedInningsNumber(nextInningsNumber - 1)
            .newInningsNumber(nextInningsNumber)
            .battingTeam(innings.getBattingTeam().getTeamName())
            .bowlingTeam(innings.getBowlingTeam().getTeamName())
            .targetScore(innings.getTargetScore())
            .build();

        sendRealTimeUpdate(match.getId(), "innings_transition", result);
        return result;
    }

    private InningsTransitionResult completeMatch(CricketMatch match) {
        // Calculate match result
        MatchResult result = calculateMatchResult(match);
        
        match.completeMatch(result.getWinningTeam(), result.getVictoryMargin(), result.getManOfTheMatch());
        cricketMatchRepository.save(match);

        // Update player statistics
        updateFinalPlayerStatistics(match);

        // Send match completion notification
        sendRealTimeUpdate(match.getId(), "match_completed", result);

        return InningsTransitionResult.builder()
            .matchId(match.getId())
            .matchCompleted(true)
            .matchResult(result.getResultText())
            .winningTeam(result.getWinningTeam().getTeamName())
            .build();
    }

    private MatchResult calculateMatchResult(CricketMatch match) {
        List<CricketInnings> completedInnings = match.getInnings().stream()
            .filter(innings -> innings.getInningsStatus() == CricketInnings.InningsStatus.COMPLETED)
            .sorted(Comparator.comparing(CricketInnings::getInningsNumber))
            .toList();

        if (completedInnings.size() < 2) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Cannot calculate result with less than 2 completed innings");
        }

        CricketInnings firstInnings = completedInnings.get(0);
        CricketInnings secondInnings = completedInnings.get(1);

        Team winningTeam;
        String victoryMargin;

        if (secondInnings.getTotalRuns() > firstInnings.getTotalRuns()) {
            // Team batting second won
            winningTeam = secondInnings.getBattingTeam();
            int wicketsRemaining = 10 - secondInnings.getTotalWickets();
            victoryMargin = wicketsRemaining + " wickets";
        } else if (firstInnings.getTotalRuns() > secondInnings.getTotalRuns()) {
            // Team batting first won
            winningTeam = firstInnings.getBattingTeam();
            int runsMargin = firstInnings.getTotalRuns() - secondInnings.getTotalRuns();
            victoryMargin = runsMargin + " runs";
        } else {
            // Tie - handle based on format rules
            return handleTieResult(match, firstInnings, secondInnings);
        }

        // Find man of the match
        User manOfTheMatch = findManOfTheMatch(match);

        String resultText = winningTeam.getTeamName() + " won by " + victoryMargin;

        return MatchResult.builder()
            .winningTeam(winningTeam)
            .victoryMargin(victoryMargin)
            .resultText(resultText)
            .manOfTheMatch(manOfTheMatch)
            .build();
    }

    private MatchResult handleTieResult(CricketMatch match, CricketInnings first, CricketInnings second) {
        // Handle tie scenarios based on format
        return MatchResult.builder()
            .winningTeam(null)
            .victoryMargin("Match Tied")
            .resultText("Match ended in a tie - " + first.getTotalRuns() + " each")
            .manOfTheMatch(findManOfTheMatch(match))
            .build();
    }

    private User findManOfTheMatch(CricketMatch match) {
        List<CricketPlayerPerformance> allPerformances = playerPerformanceRepository.findByMatchId(match.getId());
        
        return allPerformances.stream()
            .max(Comparator.comparing(CricketPlayerPerformance::getImpactScore))
            .map(CricketPlayerPerformance::getPlayer)
            .orElse(null);
    }

    private void updateFinalPlayerStatistics(CricketMatch match) {
        // Update user statistics based on cricket match performance
        List<CricketPlayerPerformance> performances = playerPerformanceRepository.findByMatchId(match.getId());
        
        for (CricketPlayerPerformance performance : performances) {
            User player = performance.getPlayer();
            
            // Update cricket-specific statistics in user profile
            updateCricketStatsForUser(player, performance, match);
        }
    }

    private void updateCricketStatsForUser(User player, CricketPlayerPerformance performance, CricketMatch match) {
        // This would update cricket-specific fields in User or CricketUserStats entity
        log.info("Updating cricket stats for player {}: {} runs, {} wickets", 
            player.getUsername(), performance.getRunsScored(), performance.getWicketsTaken());
    }

    private void checkInningsCompletion(CricketInnings innings, CricketMatch match) {
        boolean shouldEnd = false;
        CricketInnings.InningsConclusion conclusion = null;

        // Check if all wickets are down
        if (innings.getTotalWickets() >= 10) {
            shouldEnd = true;
            conclusion = CricketInnings.InningsConclusion.ALL_OUT;
        }
        
        // Check if overs are completed
        else if (innings.getOversCompleted() >= match.getMaxOversPerInnings()) {
            shouldEnd = true;
            conclusion = CricketInnings.InningsConclusion.OVERS_COMPLETED;
        }
        
        // Check if target achieved (for second innings)
        else if (innings.getTargetScore() != null && innings.getTotalRuns() >= innings.getTargetScore()) {
            shouldEnd = true;
            conclusion = CricketInnings.InningsConclusion.TARGET_ACHIEVED;
        }

        if (shouldEnd) {
            innings.endInnings(conclusion);
            completeCurrentInnings(match.getId(), conclusion);
        }
    }

    private void sendRealTimeUpdate(Long matchId, String eventType, Object data) {
        messagingTemplate.convertAndSend("/topic/cricket/" + matchId, 
            CricketRealTimeUpdate.builder()
                .eventType(eventType)
                .matchId(matchId)
                .data(data)
                .timestamp(OffsetDateTime.now())
                .build());
    }

    private void sendMilestoneNotification(Long matchId, String message) {
        sendRealTimeUpdate(matchId, "milestone", 
            MilestoneEvent.builder()
                .message(message)
                .timestamp(OffsetDateTime.now())
                .build());
    }

    // ===== SUPPORTING CLASSES =====

    public record BallDeliveryRequest(
        User bowler,
        User batsmanOnStrike,
        User batsmanNonStrike,
        Integer runs,
        CricketBall.BallOutcome outcome,
        Boolean isWicket,
        CricketPlayerPerformance.DismissalType wicketType,
        User fielder,
        Boolean isExtra,
        CricketBall.ExtraType extraType,
        String shotType,
        String commentary
    ) {}

    @lombok.Data
    @lombok.Builder
    public static class BallResult {
        private Long ballId;
        private Integer runs;
        private CricketBall.BallOutcome outcome;
        private Boolean isWicket;
        private String currentScore;
        private String oversDisplay;
        private Double runRate;
        private Double requiredRunRate;
    }

    @lombok.Data
    @lombok.Builder
    public static class TossResult {
        private Long matchId;
        private String tossWinningTeam;
        private String decision;
        private String battingFirst;
        private String bowlingFirst;
    }

    @lombok.Data
    @lombok.Builder
    public static class InningsTransitionResult {
        private Long matchId;
        private Integer completedInningsNumber;
        private Integer newInningsNumber;
        private String battingTeam;
        private String bowlingTeam;
        private Integer targetScore;
        private Boolean matchCompleted;
        private String matchResult;
        private String winningTeam;
    }

    @lombok.Data
    @lombok.Builder
    public static class MatchResult {
        private Team winningTeam;
        private String victoryMargin;
        private String resultText;
        private User manOfTheMatch;
    }

    @lombok.Data
    @lombok.Builder
    public static class CricketScorecard {
        private Long matchId;
        private CricketMatch.CricketFormat matchFormat;
        private CricketMatch.MatchStatus matchStatus;
        private Integer currentInnings;
        private List<CricketInnings> innings;
        private List<CricketPlayerPerformance> playerPerformances;
        private TossInfo tossInfo;
        private String matchResult;
        private String winningTeam;
        private String manOfTheMatch;
    }

    @lombok.Data
    @lombok.Builder
    public static class TossInfo {
        private String tossWinningTeam;
        private String decision;
    }

    @lombok.Data
    @lombok.Builder
    public static class CricketRealTimeUpdate {
        private String eventType;
        private Long matchId;
        private Object data;
        private OffsetDateTime timestamp;
    }

    @lombok.Data
    @lombok.Builder
    public static class MilestoneEvent {
        private String message;
        private OffsetDateTime timestamp;
    }

    @lombok.Data
    @lombok.Builder
    public static class MatchUpdateData {
        private Long matchId;
        private CricketMatch.MatchStatus status;
        private Integer currentInnings;
        private String battingTeam;
        private String bowlingTeam;
    }
}